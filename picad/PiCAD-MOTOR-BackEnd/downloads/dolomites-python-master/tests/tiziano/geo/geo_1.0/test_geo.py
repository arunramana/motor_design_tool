# This script try to generate a geo file starting from a triangle mesh.
# The region of a femm/tiziano file with a specified physical tag "ph_tag"
# is converted into a gmsh geo file.
# 
# In this script a single region is converted in the geo file
# 
# At the moment only simply connected domain are considered.


from dolomites import tiziano

# a reference to the tiziano model
draw = tiziano.drawing()

#### open a femm file
filename = 'example_geo.fem'
draw.open_femm(filename, scale=1)

#### save the model in tiziano format
###draw.save('example_geo.tiz')

## a dummy geometry with a hole to test
#A = 10
#p1 = draw.add_point(A,A)
#p2 = draw.add_point(-A,A)
#p3 = draw.add_point(-A,-A)
#p4 = draw.add_point(A,-A)
#B = 5
#p5 = draw.add_point( B, B)
#p6 = draw.add_point(-B, B)
#p7 = draw.add_point(-B,-B)
#p8 = draw.add_point( B,-B)

#draw.add_line(p1,p2)
#draw.add_line(p2,p3)
#draw.add_line(p3,p4)
#draw.add_line(p4,p1)
#draw.add_label((A+B)/2,0,1000,1)

#draw.add_line(p5,p6)
#draw.add_line(p6,p7)
#draw.add_line(p7,p8)
#draw.add_line(p8,p5)
#draw.add_hole(0,0)


# call traingle to generate the mesh
draw.mesh_triangle(flags='pzeA')

# save the mesh in gmsh format (just for cross check)
draw.save_mesh('example_geo.msh')

# recover elements with a specific phisical tag, i.e. one region
ph_tag = 1001

# we store all the edges of the triangles with the specific ph_tag in the list edges.
# in order to count the edges we order them according to point indexes
edges    = [] 
for e in draw.triangle_triangles:
    if e[2][0] == ph_tag:
        if e[0][0] < e[0][1]:
            edges.append((e[0][0],e[0][1]))
        else:
            edges.append((e[0][1],e[0][0]))
        if e[0][1] < e[0][2]:
            edges.append((e[0][1],e[0][2]))
        else:
            edges.append((e[0][2],e[0][1]))
        if e[0][2] < e[0][0]:
            edges.append((e[0][2],e[0][0]))
        else:
            edges.append((e[0][0],e[0][2]))

# edges now contains also internal edges that have to be removed.
# The border of the region is made by the edges that appear exactly one time
# in the list (i.e. that blong to just one triangle, internal edges belong to
# two triangles)                

# we recover the nodes of the mesh to reconstruct the geometry
nodes    = draw.triangle_points

# we build a new model with the boundary of the region "ph_tag"
draw1 = tiziano.drawing()
for l in edges:
    if edges.count(l) < 2:
        p1 = draw1.add_point(nodes[l[0]][0][0],nodes[l[0]][0][1])
        p2 = draw1.add_point(nodes[l[1]][0][0],nodes[l[1]][0][1])
        draw1.add_line(p1,p2)


# recover the geometry of the region border
points   = draw1.get_points()
lines,_  = draw1.get_lines()





# reconstruct line loops
from copy import deepcopy

edges = deepcopy(lines) # all the edges that have to be subdivided into lineloops
loops = []        # a list of all the loops that describe the surface 
loops_inc = []    # and its incidences



print(edges)
while len(edges)>0:
    loop = []
    loop_inc = []
    loop.append(edges.pop(0)) # add the first element
    loop_inc.append(1)
    start = loop[0][0]
    end   = loop[0][1]
    begin = loop[0] # the begin of the lineloop
    #print('start ',start)
    #print('end ',end)
    
    #while (end != begin) or (start != begin):
    #while ((end not in begin) and (start not in begin)) or (len(loop)<2):
    while ((end not in begin) or (len(loop)<2)):
        print('edges',edges)
        print('loop',loop)
        print('loop_inc',loop_inc)
        print(begin, start, end)
        #input()
        for k in edges:
            #j = [i for i in edges if (end in i or start in i)]
            j = [i for i in edges if (end in i)]
            print('j ',j)
            if len(j)>0:
                loop.append(j[0])
                edges.remove(j[0])
                if j[0][0]==end:
                    loop_inc.append(1)
                    start = j[0][0]
                    end   = j[0][1]
                else:
                    loop_inc.append(-1)
                    start = j[0][1]
                    end   = j[0][0]
        print(loop)
        print(loop_inc)
    loops.append(loop)
    loops_inc.append(loop_inc)

print(loops)
print(loops_inc)
    


# save the geo file
filename = 'example_geo.geo'
with open(filename, 'w') as fp:

            # write out file heading
            fp.write('// File generated by dolomites/tiziano\n')

            fp.write('cl = 1;\n')
            # write out points
            # Point(5)={5.0, 5.0, 0, cl};
            for i, p in enumerate(points):
                fp.write(('Point(%s)={%s, %s, 0, cl};\n') % (i+1, p[0], p[1]))
            # write out lines
            # Line(1) = {1, 2};
            for i,l in enumerate (lines):
                fp.write(('Line(%s)={%s, %s};\n') % (i+1, l[0]+1, l[1]+1))
            # write out lineloops
            # Curve Loop(1) = {7, 4, 2, -5};
            for i,l in enumerate (loops):
                fp.write(('Curve Loop(%s)={') % (i+1))
                for j,_l in enumerate (l):
                    fp.write(str((lines.index(_l)+1) * loops_inc[i][j]))
                    if j<len(l)-1:
                        fp.write(', ')
                fp.write('};\n')
            # write surface
            #Plane Surface(1) = {1, 2};
            fp.write('Plane Surface(1) = ' + str({i+1 for i in range(len(loops))})+';\n')

# questo funziona per un singolo tag fisico.
# se voglio convertire un intero modello conviene procedere nel seguente modo:
# - genero una lista con tutti i lati dei triangoli associandovi anche i ph_tag del triangolo di cui sono bordo
#   se c'è un solo tag sono lati interni. Se hanno 2 tag (il massimo) sono parte di linee geometriche
# - procedo come già implementato su sottoinsieme di lati filtrati per tag

