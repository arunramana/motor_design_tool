# This script try to generate a geo file starting from a tiziano model (triangle mesh.)
# This has to be considered higly experimental. Being a conversion between
# cad model this is also deprecated by someone.
# The regions of a tiziano (femm) model with a specified physical tag "ph_tag"
# is converted into a gmsh physical surface.
# In order to properly work, each surface must have a ph_tag,i.e. it is
# not enough robust to group different surface into a single physical group
# Note that if the same ph_tag is assigned to connected regions (sharing a
# border for example), a single surface will be correctly generated in the geo file
# (for example different part of the  stator iron).
# This is not the case if the same tag is assigned to separate regions
# (for example stator slot openings)

from copy import deepcopy

def create_surfaces(lines):
    """
    # reconstruct line loops from the bordes dict
    lines: the list of edges that has to be subdivided into loops to form the gmsh surface
    """
    edges = deepcopy(lines) # all the edges that have to be subdivided into lineloops
    loops = []        # a list of all the loops that describe the surface 
    loops_inc = []    # and its incidences

    #print(edges)
    while len(edges)>0:
        loop = []
        loop_inc = []
        loop.append(edges.pop(0)) # add the first element
        loop_inc.append(1)
        start = loop[0][0]
        end   = loop[0][1]
        begin = loop[0] # the begin of the lineloop
        #print('start ',start)
        #print('end ',end)
        
        #while (end != begin) or (start != begin):
        #while ((end not in begin) and (start not in begin)) or (len(loop)<2):
        while ((end not in begin) or (len(loop)<2)):
            #print('edges',edges)
            #print('loop',loop)
            #print('loop_inc',loop_inc)
            #print(begin, start, end)
            #input()
            for k in edges:
                #j = [i for i in edges if (end in i or start in i)]
                j = [i for i in edges if (end in i)]
                #print('j ',j)
                if len(j)>0:
                    loop.append(j[0])
                    edges.remove(j[0])
                    if j[0][0]==end:
                        loop_inc.append(1)
                        start = j[0][0]
                        end   = j[0][1]
                    else:
                        loop_inc.append(-1)
                        start = j[0][1]
                        end   = j[0][0]
            #print(loop)
            #print(loop_inc)
        loops.append(loop)
        loops_inc.append(loop_inc)

    # print(loops)
    # print(loops_inc)
    # loops: a list of loop which are the border of the surface
    #        (including holes)
    # loops_inc: a list of the 
    return loops,loops_inc

def save_geo(nodes,lines,surfaces, filename='example.geo',cl=1):
    # save the geo file
    with open(filename, 'w') as fp:

                # write out file heading
                fp.write('// File generated by dolomites/tiziano\n')

                fp.write(('cl = %s;\n')%(cl))
                # write out points
                # Point(5)={5.0, 5.0, 0, cl};
                for i, p in enumerate(nodes):
                    fp.write(('Point(%s)={%s, %s, 0, cl};\n') % (i+1, p[0][0],p[0][1]))
                # write out lines
                # Line(1) = {1, 2};
                for i,l in enumerate (lines):
                    fp.write(('Line(%s)={%s, %s};\n') % (i+1, l[0]+1, l[1]+1))

                # write out lineloops
                # Curve Loop(1) = {7, 4, 2, -5};
                id_ll = 0
                for id_s,(key, [loops,loops_inc]) in enumerate(surfaces.items()):
                    for i,l in enumerate (loops):
                        fp.write(('\nCurve Loop(%s)={') % (id_ll+1))
                        id_ll+=1
                        for j,_l in enumerate (l):
                            fp.write(str((lines.index(_l)+1) * loops_inc[i][j]))
                            if j<len(l)-1:
                                fp.write(', ')
                        fp.write('};\n')
                    # write surface
                    #Plane Surface(1) = {1, 2};
                    fp.write('Plane Surface('+str(id_s+1) + ') = ' + str({id_ll+i-len(loops)+1 for i in range(len(loops))})+';\n')
                    fp.write('Physical Surface('+str(key) + ') = {' + str(id_s+1)+'};\n')

        

from dolomites import tiziano

# a reference to the tiziano model
draw = tiziano.drawing()

#### open a femm file
filename = 'example.fem'
draw.open_femm(filename, scale=1)

#### save the model in tiziano format
###draw.save('example_geo.tiz')

## a dummy geometry with a hole to test
#A = 10
#p1 = draw.add_point(A,A)
#p2 = draw.add_point(-A,A)
#p3 = draw.add_point(-A,-A)
#p4 = draw.add_point(A,-A)
#B = 5
#p5 = draw.add_point( B, B)
#p6 = draw.add_point(-B, B)
#p7 = draw.add_point(-B,-B)
#p8 = draw.add_point( B,-B)

#draw.add_line(p1,p2)
#draw.add_line(p2,p3)
#draw.add_line(p3,p4)
#draw.add_line(p4,p1)
#draw.add_label((A+B)/2,0,1000,1)

#draw.add_line(p5,p6)
#draw.add_line(p6,p7)
#draw.add_line(p7,p8)
#draw.add_line(p8,p5)
#draw.add_label(0,0,2000,1)


# call traingle to generate the mesh
draw.mesh_triangle(flags='pzeA')

# save the mesh in gmsh format (just for cross check)
draw.save_mesh('example_geo.msh')


# we store all the edges of the mesh along with the phisical tags of
# the triangles that share the edge.
# Outer edges have a single physical tag.
# Edges on the border between two regions have two different physical tags
# Edges inside a region have two equal physical tags


# we recover the nodes of the mesh to reconstruct the geometry
nodes    = draw.triangle_points
# we recover the triangle of the mesh to reconstruct the geometry
triangles = draw.triangle_triangles

edges    = dict() 
# edges is a dict key:value
# where the key is the edge pair (a,b) and the value a list of ph_tags

ph_tags_list = [] # a list of all the physical tags in the mesh
for e in triangles:
    ph_tag = e[2][0]
    if ph_tag not in ph_tags_list:
        ph_tags_list.append(ph_tag)
        
    if e[0][0] < e[0][1]:
        a1 = e[0][0]; b1 = e[0][1]
    else:
        a1 = e[0][1]; b1 = e[0][0]
        
    if e[0][1] < e[0][2]:
        a2 = e[0][1]; b2 = e[0][2]
    else:
        a2 = e[0][2]; b2 = e[0][1]
        
    if e[0][2] < e[0][0]:
        a3 = e[0][2]; b3 = e[0][0]
    else:
        a3 = e[0][0]; b3 = e[0][2]

    if (a1,b1) in edges:
        edges[(a1,b1)].append(ph_tag)
    else:
        edges[(a1,b1)]=[ph_tag]

    if (a2,b2) in edges:
        edges[(a2,b2)].append(ph_tag)
    else:
        edges[(a2,b2)]=[ph_tag]

    if (a3,b3) in edges:
        edges[(a3,b3)].append(ph_tag)
    else:
        edges[(a3,b3)]=[ph_tag]

#print(edges)
#print(len(edges))
#print(ph_tags_list)
#exit()

# edges now contains also internal edges that have to be removed.

# choose the edges with two different ph_tag, i.e. the region borders
# and create a new dict "borders"

borders = dict()
for e in edges:
    if edges[e].count(edges[e][0]) <= 1:
        borders[e] = edges[e]

#print(borders)
#exit()


# we iterate over all the ph_tag in the model
surfaces = dict()
for tag in ph_tags_list:

    lines = [key  for (key, value) in borders.items() if tag in value]
    [loops,loops_inc] = create_surfaces(lines)
    surfaces[tag] = [loops,loops_inc]

print('The following physical tags have been found: ',surfaces.keys())

save_geo(nodes,[key  for (key, value) in borders.items()],surfaces,cl=5e-3)




